import discord
from discord.ext import commands
import logging
import asyncio
import datetime
from database.connection import Database
from database.models import Player, Server, GuildConfig
import bson

logger = logging.getLogger('deadside_bot.cogs.stats')

# Create slash command group for stats commands
stats_group = discord.SlashCommandGroup(
    name="stats",
    description="Commands for viewing player and server statistics",
)

class StatsCommands(commands.Cog):
    """Commands for viewing player and server statistics"""
    
    def __init__(self, bot):
        self.bot = bot
        self.db = getattr(bot, 'db', None)  # Get db from bot if available
        
    async def cog_load(self):
        """Called when the cog is loaded"""
        logger.info("Stats commands cog loaded")
    
    # This function is needed to expose the commands to the bot
    def get_commands(self):
        """Return all commands this cog provides"""
        return [stats_group]
    
    @stats_group.command(
        name="player",
        description="View detailed statistics for a player"
    )
    async def stats_player(
        self, 
        ctx, 
        player_name: discord.Option(str, description="Player name to search for", required=True),
        server_name: discord.Option(str, description="Server to check (default: all accessible servers)", required=False) = None
    ):
        """View detailed statistics for a player"""
        await ctx.defer()
        
        if not self.db:
            await ctx.respond("‚ùå Database not initialized")
            return
        
        try:
            guild_id = str(ctx.guild.id) if ctx.guild else None
            server_query = {}
            
            # If server name is specified, filter by it
            if server_name:
                server_query["name"] = {"$regex": server_name, "$options": "i"}
            
            # If guild_id is provided, filter by it
            if guild_id:
                server_query["guild_id"] = guild_id
                
            # Get servers accessible to this guild
            servers_collection = await self.db.get_collection("servers")
            all_servers = await servers_collection.find(server_query).to_list(None)
            
            if not all_servers:
                # No matching servers
                if server_name:
                    await ctx.respond(f"‚ùå No servers found matching '{server_name}'")
                else:
                    await ctx.respond("‚ùå No servers accessible to this guild")
                return
                
            # Find the player in each server
            players_collection = await self.db.get_collection("players")
            player_query = {
                "name": {"$regex": f"^{player_name}$", "$options": "i"},
                "server_id": {"$in": [str(server["_id"]) for server in all_servers]}
            }
            
            all_players = await players_collection.find(player_query).to_list(None)
            
            if not all_players:
                await ctx.respond(f"‚ùå No player found with name '{player_name}'")
                return
                
            # Check if the player has linked alt accounts
            player_data = all_players[0]  # Use the first one found
            alts = []
            
            if hasattr(player_data, 'alt_player_ids') and player_data.alt_player_ids:
                # This is a main account with alts
                alt_ids = player_data.alt_player_ids
                alt_players = await players_collection.find({"_id": {"$in": alt_ids}}).to_list(None)
                alts = alt_players
                
            elif hasattr(player_data, 'main_player_id') and player_data.main_player_id:
                # This is an alt account, get the main and other alts
                main_id = player_data.main_player_id
                main_player = await players_collection.find_one({"_id": main_id})
                
                if main_player and hasattr(main_player, 'alt_player_ids'):
                    alt_ids = main_player.alt_player_ids
                    alt_players = await players_collection.find({"_id": {"$in": alt_ids}}).to_list(None)
                    alts = alt_players
                    player_data = main_player  # Use the main account for display
            
            # Create the embed
            embed = discord.Embed(
                title=f"üìä Stats for {player_data['name']}",
                description=f"Statistics for player across {len(all_servers)} server(s)",
                color=discord.Color.green()
            )
            
            # Add total kills and deaths across all servers
            total_kills = sum(p.get('kills', 0) for p in all_players)
            total_deaths = sum(p.get('deaths', 0) for p in all_players)
            kd_ratio = total_kills / total_deaths if total_deaths > 0 else total_kills
            
            # If we have linked alts, add their stats
            if alts:
                total_kills += sum(alt.get('kills', 0) for alt in alts)
                total_deaths += sum(alt.get('deaths', 0) for alt in alts)
                kd_ratio = total_kills / total_deaths if total_deaths > 0 else total_kills
                
                alt_names = ", ".join([alt.get('name', 'Unknown') for alt in alts])
                embed.add_field(
                    name="üîÑ Linked Accounts",
                    value=f"Main: {player_data['name']}\nAlts: {alt_names}",
                    inline=False
                )
            
            embed.add_field(
                name="‚ò†Ô∏è Overall Stats",
                value=f"Kills: {total_kills}\nDeaths: {total_deaths}\nK/D Ratio: {kd_ratio:.2f}",
                inline=False
            )
            
            # Add server-specific stats
            for player in all_players:
                server = next((s for s in all_servers if str(s["_id"]) == player.get("server_id")), None)
                if server:
                    server_name = server.get("name", "Unknown Server")
                    kills = player.get("kills", 0)
                    deaths = player.get("deaths", 0)
                    kd = kills / deaths if deaths > 0 else kills
                    
                    embed.add_field(
                        name=f"üéÆ {server_name}",
                        value=f"Kills: {kills}\nDeaths: {deaths}\nK/D: {kd:.2f}",
                        inline=True
                    )
            
            # Add favorite weapons if available
            weapons_data = player_data.get("weapons", {})
            if weapons_data:
                # Sort weapons by kill count
                sorted_weapons = sorted(weapons_data.items(), key=lambda x: x[1], reverse=True)
                top_weapons = sorted_weapons[:3]  # Top 3 weapons
                
                weapons_text = "\n".join([f"{weapon}: {kills} kills" for weapon, kills in top_weapons])
                embed.add_field(
                    name="üî´ Top Weapons",
                    value=weapons_text if weapons_text else "No weapon data available",
                    inline=False
                )
            
            # Add last seen information if available
            if "last_seen" in player_data:
                last_seen = player_data["last_seen"]
                if isinstance(last_seen, datetime.datetime):
                    # Format for display
                    time_diff = datetime.datetime.utcnow() - last_seen
                    if time_diff.days > 0:
                        last_seen_str = f"{time_diff.days} days ago"
                    elif time_diff.seconds > 3600:
                        last_seen_str = f"{time_diff.seconds // 3600} hours ago"
                    else:
                        last_seen_str = f"{time_diff.seconds // 60} minutes ago"
                        
                    embed.add_field(
                        name="‚è±Ô∏è Last Seen",
                        value=last_seen_str,
                        inline=True
                    )
            
            # Send the embed
            await ctx.respond(embed=embed)
            
        except Exception as e:
            logger.error(f"Error in stats_player: {e}")
            await ctx.respond(f"‚ùå Error retrieving player stats: {e}")
    
    @stats_group.command(
        name="leaderboard",
        description="View server leaderboard"
    )
    async def stats_leaderboard(
        self, 
        ctx, 
        server_name: discord.Option(str, description="Server to show leaderboard for", required=False) = None,
        stat_type: discord.Option(str, description="Stat to sort by", choices=["kills", "deaths", "kd", "time"], required=False) = "kills",
        timeframe: discord.Option(str, description="Time period to show", choices=["all", "week", "day"], required=False) = "all"
    ):
        """View server leaderboard"""
        await ctx.defer()
        
        if not self.db:
            await ctx.respond("‚ùå Database not initialized")
            return
        
        try:
            guild_id = str(ctx.guild.id) if ctx.guild else None
            server_query = {}
            
            # If server name is specified, filter by it
            if server_name:
                server_query["name"] = {"$regex": server_name, "$options": "i"}
            
            # If guild_id is provided, filter by it
            if guild_id:
                server_query["guild_id"] = guild_id
                
            # Get servers accessible to this guild
            servers_collection = await self.db.get_collection("servers")
            all_servers = await servers_collection.find(server_query).to_list(None)
            
            if not all_servers:
                # No matching servers
                if server_name:
                    await ctx.respond(f"‚ùå No servers found matching '{server_name}'")
                else:
                    await ctx.respond("‚ùå No servers accessible to this guild")
                return
                
            # If multiple servers match and none was specified, ask the user to specify
            if len(all_servers) > 1 and not server_name:
                server_list = "\n".join([f"{i+1}. {server['name']}" for i, server in enumerate(all_servers[:10])])
                await ctx.respond(f"Multiple servers found. Please specify a server name:\n{server_list}")
                return
            
            # Use the first server that matched
            server = all_servers[0]
            server_id = str(server["_id"])
            
            # Get timeframe filter if needed
            date_filter = {}
            if timeframe != "all":
                # Calculate the date range
                now = datetime.datetime.utcnow()
                if timeframe == "week":
                    start_date = now - datetime.timedelta(days=7)
                elif timeframe == "day":
                    start_date = now - datetime.timedelta(days=1)
                    
                date_filter = {"last_seen": {"$gte": start_date}}
            
            # Build query for player stats
            query = {"server_id": server_id}
            if date_filter:
                query.update(date_filter)
                
            # Get players for this server
            players_collection = await self.db.get_collection("players")
            all_players = await players_collection.find(query).to_list(None)
            
            if not all_players:
                await ctx.respond(f"‚ùå No players found for server '{server['name']}' in the selected timeframe")
                return
            
            # Sort players by the requested stat
            if stat_type == "kills":
                all_players.sort(key=lambda p: p.get("kills", 0), reverse=True)
                stat_label = "Kills"
            elif stat_type == "deaths":
                all_players.sort(key=lambda p: p.get("deaths", 0), reverse=True)
                stat_label = "Deaths"
            elif stat_type == "kd":
                # Calculate K/D ratio for each player
                for player in all_players:
                    kills = player.get("kills", 0)
                    deaths = player.get("deaths", 0)
                    player["kd"] = kills / deaths if deaths > 0 else kills
                all_players.sort(key=lambda p: p.get("kd", 0), reverse=True)
                stat_label = "K/D Ratio"
            elif stat_type == "time":
                all_players.sort(key=lambda p: p.get("time_played", 0), reverse=True)
                stat_label = "Time Played"
            
            # Create embed for the leaderboard
            embed = discord.Embed(
                title=f"üèÜ {server['name']} Leaderboard",
                description=f"Top players sorted by {stat_label} ‚Ä¢ {timeframe.capitalize()} time stats",
                color=discord.Color.gold()
            )
            
            # Add top 10 players
            leaderboard_text = ""
            for i, player in enumerate(all_players[:10]):
                name = player.get("name", "Unknown")
                if stat_type == "kills":
                    value = player.get("kills", 0)
                    leaderboard_text += f"{i+1}. **{name}** - {value} kills\n"
                elif stat_type == "deaths":
                    value = player.get("deaths", 0)
                    leaderboard_text += f"{i+1}. **{name}** - {value} deaths\n"
                elif stat_type == "kd":
                    value = player.get("kd", 0)
                    leaderboard_text += f"{i+1}. **{name}** - {value:.2f} K/D\n"
                elif stat_type == "time":
                    minutes = player.get("time_played", 0)
                    hours = minutes // 60
                    mins = minutes % 60
                    leaderboard_text += f"{i+1}. **{name}** - {hours}h {mins}m\n"
            
            embed.add_field(
                name=f"Top Players by {stat_label}",
                value=leaderboard_text if leaderboard_text else "No players found",
                inline=False
            )
            
            # Add server info
            embed.set_footer(text=f"Server: {server['name']} ‚Ä¢ Total players: {len(all_players)}")
            
            # Send the embed
            await ctx.respond(embed=embed)
            
        except Exception as e:
            logger.error(f"Error in stats_leaderboard: {e}")
            await ctx.respond(f"‚ùå Error retrieving leaderboard: {e}")
    
    @stats_group.command(
        name="weapons",
        description="View weapon usage statistics for a server"
    )
    async def stats_weapons(
        self, 
        ctx, 
        server_name: discord.Option(str, description="Server to show stats for", required=False) = None
    ):
        """View weapon usage statistics for a server"""
        await ctx.defer()
        
        if not self.db:
            await ctx.respond("‚ùå Database not initialized")
            return
        
        try:
            guild_id = str(ctx.guild.id) if ctx.guild else None
            server_query = {}
            
            # If server name is specified, filter by it
            if server_name:
                server_query["name"] = {"$regex": server_name, "$options": "i"}
            
            # If guild_id is provided, filter by it
            if guild_id:
                server_query["guild_id"] = guild_id
                
            # Get servers accessible to this guild
            servers_collection = await self.db.get_collection("servers")
            all_servers = await servers_collection.find(server_query).to_list(None)
            
            if not all_servers:
                # No matching servers
                if server_name:
                    await ctx.respond(f"‚ùå No servers found matching '{server_name}'")
                else:
                    await ctx.respond("‚ùå No servers accessible to this guild")
                return
                
            # If multiple servers match and none was specified, ask the user to specify
            if len(all_servers) > 1 and not server_name:
                server_list = "\n".join([f"{i+1}. {server['name']}" for i, server in enumerate(all_servers[:10])])
                await ctx.respond(f"Multiple servers found. Please specify a server name:\n{server_list}")
                return
            
            # Use the first server that matched
            server = all_servers[0]
            server_id = str(server["_id"])
            
            # Get players for this server
            players_collection = await self.db.get_collection("players")
            all_players = await players_collection.find({"server_id": server_id}).to_list(None)
            
            if not all_players:
                await ctx.respond(f"‚ùå No players found for server '{server['name']}'")
                return
            
            # Aggregate all weapon data
            weapon_stats = {}
            for player in all_players:
                weapons = player.get("weapons", {})
                for weapon, kills in weapons.items():
                    if weapon in weapon_stats:
                        weapon_stats[weapon] += kills
                    else:
                        weapon_stats[weapon] = kills
            
            if not weapon_stats:
                await ctx.respond(f"‚ùå No weapon data found for server '{server['name']}'")
                return
                
            # Sort weapons by kill count
            sorted_weapons = sorted(weapon_stats.items(), key=lambda x: x[1], reverse=True)
            
            # Create the embed
            embed = discord.Embed(
                title=f"üî´ Weapon Stats for {server['name']}",
                description=f"Weapon usage statistics across {len(all_players)} players",
                color=discord.Color.blue()
            )
            
            # Split into multiple fields if needed
            weapon_chunks = [sorted_weapons[i:i+10] for i in range(0, min(30, len(sorted_weapons)), 10)]
            
            for i, chunk in enumerate(weapon_chunks):
                chunk_text = "\n".join([f"**{weapon}**: {kills} kills" for weapon, kills in chunk])
                embed.add_field(
                    name=f"Top Weapons {i*10+1}-{i*10+len(chunk)}",
                    value=chunk_text,
                    inline=True
                )
            
            # Add server info footer
            total_kills = sum(kills for _, kills in sorted_weapons)
            embed.set_footer(text=f"Server: {server['name']} ‚Ä¢ Total kills: {total_kills}")
            
            # Send the embed
            await ctx.respond(embed=embed)
            
        except Exception as e:
            logger.error(f"Error in stats_weapons: {e}")
            await ctx.respond(f"‚ùå Error retrieving weapon stats: {e}")
    
    @stats_group.command(
        name="deaths",
        description="View death statistics for a player or server"
    )
    async def stats_deaths(
        self, 
        ctx, 
        player_name: discord.Option(str, description="Player name (leave empty for server stats)", required=False) = None,
        server_name: discord.Option(str, description="Server to show stats for", required=False) = None
    ):
        """View death statistics for a player or server"""
        await ctx.defer()
        
        if not self.db:
            await ctx.respond("‚ùå Database not initialized")
            return
        
        try:
            guild_id = str(ctx.guild.id) if ctx.guild else None
            server_query = {}
            
            # If server name is specified, filter by it
            if server_name:
                server_query["name"] = {"$regex": server_name, "$options": "i"}
            
            # If guild_id is provided, filter by it
            if guild_id:
                server_query["guild_id"] = guild_id
                
            # Get servers accessible to this guild
            servers_collection = await self.db.get_collection("servers")
            all_servers = await servers_collection.find(server_query).to_list(None)
            
            if not all_servers:
                # No matching servers
                if server_name:
                    await ctx.respond(f"‚ùå No servers found matching '{server_name}'")
                else:
                    await ctx.respond("‚ùå No servers accessible to this guild")
                return
                
            # If multiple servers match and none was specified, ask the user to specify
            if len(all_servers) > 1 and not server_name:
                server_list = "\n".join([f"{i+1}. {server['name']}" for i, server in enumerate(all_servers[:10])])
                await ctx.respond(f"Multiple servers found. Please specify a server name:\n{server_list}")
                return
            
            # Use the first server that matched
            server = all_servers[0]
            server_id = str(server["_id"])
            
            # Get players for this server
            players_collection = await self.db.get_collection("players")
            
            if player_name:
                # Get a specific player's death stats
                player_query = {
                    "name": {"$regex": f"^{player_name}$", "$options": "i"},
                    "server_id": server_id
                }
                
                player = await players_collection.find_one(player_query)
                
                if not player:
                    await ctx.respond(f"‚ùå Player '{player_name}' not found on server '{server['name']}'")
                    return
                
                # Get death stats
                deaths_collection = await self.db.get_collection("deaths")
                death_query = {
                    "victim_id": str(player["_id"]),
                    "server_id": server_id
                }
                
                # Aggregate deaths by killer
                pipeline = [
                    {"$match": death_query},
                    {"$group": {
                        "_id": "$killer_id",
                        "count": {"$sum": 1},
                        "killer_name": {"$first": "$killer_name"},
                        "weapons": {"$push": "$weapon"}
                    }},
                    {"$sort": {"count": -1}},
                    {"$limit": 10}
                ]
                
                killer_stats = await deaths_collection.aggregate(pipeline).to_list(None)
                
                # Create the embed
                embed = discord.Embed(
                    title=f"üíÄ Death Stats for {player['name']}",
                    description=f"Death analysis on server '{server['name']}'",
                    color=discord.Color.red()
                )
                
                # Add top killers
                if killer_stats:
                    killer_text = "\n".join([f"**{stat['killer_name']}**: {stat['count']} kills" for stat in killer_stats])
                    embed.add_field(
                        name="Top Killers",
                        value=killer_text,
                        inline=False
                    )
                else:
                    embed.add_field(
                        name="Top Killers",
                        value="No death data available",
                        inline=False
                    )
                
                # Add weapon stats - what weapons killed this player the most
                weapon_counts = {}
                for stat in killer_stats:
                    for weapon in stat['weapons']:
                        if weapon in weapon_counts:
                            weapon_counts[weapon] += 1
                        else:
                            weapon_counts[weapon] = 1
                
                if weapon_counts:
                    sorted_weapons = sorted(weapon_counts.items(), key=lambda x: x[1], reverse=True)[:5]
                    weapon_text = "\n".join([f"**{weapon}**: {count} deaths" for weapon, count in sorted_weapons])
                    embed.add_field(
                        name="Killed By Weapons",
                        value=weapon_text,
                        inline=False
                    )
                
                # Add general player stats
                embed.add_field(
                    name="Player Stats",
                    value=f"Kills: {player.get('kills', 0)}\nDeaths: {player.get('deaths', 0)}",
                    inline=True
                )
                
                # Add footer
                embed.set_footer(text=f"Server: {server['name']}")
                
            else:
                # Show server-wide death stats
                # Get all player deaths
                deaths_collection = await self.db.get_collection("deaths")
                death_query = {"server_id": server_id}
                
                # Get most common weapons
                weapon_pipeline = [
                    {"$match": death_query},
                    {"$group": {
                        "_id": "$weapon",
                        "count": {"$sum": 1}
                    }},
                    {"$sort": {"count": -1}},
                    {"$limit": 10}
                ]
                
                weapon_stats = await deaths_collection.aggregate(weapon_pipeline).to_list(None)
                
                # Get most common kill locations
                location_pipeline = [
                    {"$match": death_query},
                    {"$group": {
                        "_id": "$location",
                        "count": {"$sum": 1}
                    }},
                    {"$sort": {"count": -1}},
                    {"$limit": 10}
                ]
                
                location_stats = await deaths_collection.aggregate(location_pipeline).to_list(None)
                
                # Create the embed
                embed = discord.Embed(
                    title=f"üíÄ Server Death Analysis",
                    description=f"Death statistics for '{server['name']}'",
                    color=discord.Color.red()
                )
                
                # Add weapon stats
                if weapon_stats:
                    weapon_text = "\n".join([f"**{stat['_id']}**: {stat['count']} kills" for stat in weapon_stats])
                    embed.add_field(
                        name="Top Weapons",
                        value=weapon_text,
                        inline=True
                    )
                
                # Add location stats
                if location_stats:
                    location_text = "\n".join([f"**{stat['_id']}**: {stat['count']} deaths" for stat in location_stats])
                    embed.add_field(
                        name="Deadliest Locations",
                        value=location_text,
                        inline=True
                    )
                
                # Add total death count
                total_deaths = await deaths_collection.count_documents(death_query)
                embed.add_field(
                    name="Total Deaths",
                    value=str(total_deaths),
                    inline=False
                )
                
                # Add footer
                embed.set_footer(text=f"Server: {server['name']}")
            
            # Send the embed
            await ctx.respond(embed=embed)
            
        except Exception as e:
            logger.error(f"Error in stats_deaths: {e}")
            await ctx.respond(f"‚ùå Error retrieving death stats: {e}")
    
    @stats_group.command(
        name="link",
        description="Link your main and alt characters together"
    )
    async def stats_link(
        self,
        ctx,
        main_name: discord.Option(str, description="Your main character name", required=True),
        alt_name: discord.Option(str, description="Your alt character name to link", required=True),
        server_name: discord.Option(str, description="Server where both characters exist", required=False) = None
    ):
        """Link your main and alt characters together for unified stats"""
        await ctx.defer()
        
        if not self.db:
            await ctx.respond("‚ùå Database not initialized")
            return
        
        try:
            guild_id = str(ctx.guild.id) if ctx.guild else None
            server_query = {}
            
            # If server name is specified, filter by it
            if server_name:
                server_query["name"] = {"$regex": server_name, "$options": "i"}
            
            # If guild_id is provided, filter by it
            if guild_id:
                server_query["guild_id"] = guild_id
                
            # Get servers accessible to this guild
            servers_collection = await self.db.get_collection("servers")
            all_servers = await servers_collection.find(server_query).to_list(None)
            
            if not all_servers:
                # No matching servers
                if server_name:
                    await ctx.respond(f"‚ùå No servers found matching '{server_name}'")
                else:
                    await ctx.respond("‚ùå No servers accessible to this guild")
                return
                
            # If multiple servers match and none was specified, ask the user to specify
            if len(all_servers) > 1 and not server_name:
                server_list = "\n".join([f"{i+1}. {server['name']}" for i, server in enumerate(all_servers[:10])])
                await ctx.respond(f"Multiple servers found. Please specify a server name:\n{server_list}")
                return
            
            # Use the first server that matched
            server = all_servers[0]
            server_id = str(server["_id"])
            
            # Get players for this server
            players_collection = await self.db.get_collection("players")
            
            # Find main character
            main_query = {
                "name": {"$regex": f"^{main_name}$", "$options": "i"},
                "server_id": server_id
            }
            
            main_player = await players_collection.find_one(main_query)
            
            if not main_player:
                await ctx.respond(f"‚ùå Main character '{main_name}' not found on server '{server['name']}'")
                return
                
            # Find alt character
            alt_query = {
                "name": {"$regex": f"^{alt_name}$", "$options": "i"},
                "server_id": server_id
            }
            
            alt_player = await players_collection.find_one(alt_query)
            
            if not alt_player:
                await ctx.respond(f"‚ùå Alt character '{alt_name}' not found on server '{server['name']}'")
                return
                
            # Check if they're already linked
            if 'main_player_id' in alt_player:
                await ctx.respond(f"‚ùå '{alt_name}' is already linked to another main character")
                return
                
            # Update the alt to point to the main
            await players_collection.update_one(
                {"_id": alt_player["_id"]},
                {"$set": {"main_player_id": main_player["_id"]}}
            )
            
            # Update the main to include the alt
            alt_player_ids = main_player.get("alt_player_ids", [])
            alt_player_ids.append(alt_player["_id"])
            
            await players_collection.update_one(
                {"_id": main_player["_id"]},
                {"$set": {"alt_player_ids": alt_player_ids}}
            )
            
            # Send confirmation
            await ctx.respond(f"‚úÖ Successfully linked '{alt_name}' as an alt of '{main_name}'")
            
        except Exception as e:
            logger.error(f"Error in stats_link: {e}")
            await ctx.respond(f"‚ùå Error linking characters: {e}")
    
    @stats_group.command(
        name="rivals",
        description="View your top rivals (players who kill you or get killed by you the most)"
    )
    async def stats_rivals(
        self,
        ctx,
        player_name: discord.Option(str, description="Your character name", required=True),
        server_name: discord.Option(str, description="Server to check", required=False) = None
    ):
        """View your top rivals (nemesis and prey)"""
        await ctx.defer()
        
        if not self.db:
            await ctx.respond("‚ùå Database not initialized")
            return
        
        try:
            guild_id = str(ctx.guild.id) if ctx.guild else None
            
            # Verify premium tier for this feature
            premium_status = "Free"  # Default to free tier
            
            if guild_id and hasattr(self.bot, 'db'):
                # Check if we have guild premium configuration
                try:
                    configs = await self.bot.db.get_collection("guild_configs")
                    guild_config = await configs.find_one({"guild_id": guild_id})
                    if guild_config and "premium_tier" in guild_config:
                        premium_status = guild_config["premium_tier"]
                except Exception as e:
                    logger.error(f"Error checking premium status: {e}")
            
            # This is a premium feature
            if premium_status not in ["Warlord", "Overseer"]:
                embed = discord.Embed(
                    title="Premium Feature",
                    description="Rivalry tracking is a premium feature",
                    color=discord.Color.gold()
                )
                embed.add_field(
                    name="Upgrade to Premium",
                    value="This feature requires Warlord tier or higher."
                )
                await ctx.respond(embed=embed)
                return
            
            # Continue with server lookup
            server_query = {}
            
            # If server name is specified, filter by it
            if server_name:
                server_query["name"] = {"$regex": server_name, "$options": "i"}
            
            # If guild_id is provided, filter by it
            if guild_id:
                server_query["guild_id"] = guild_id
                
            # Get servers accessible to this guild
            servers_collection = await self.db.get_collection("servers")
            all_servers = await servers_collection.find(server_query).to_list(None)
            
            if not all_servers:
                # No matching servers
                if server_name:
                    await ctx.respond(f"‚ùå No servers found matching '{server_name}'")
                else:
                    await ctx.respond("‚ùå No servers accessible to this guild")
                return
                
            # If multiple servers match and none was specified, ask the user to specify
            if len(all_servers) > 1 and not server_name:
                server_list = "\n".join([f"{i+1}. {server['name']}" for i, server in enumerate(all_servers[:10])])
                await ctx.respond(f"Multiple servers found. Please specify a server name:\n{server_list}")
                return
            
            # Use the first server that matched
            server = all_servers[0]
            server_id = str(server["_id"])
            
            # Find the player
            players_collection = await self.db.get_collection("players")
            player_query = {
                "name": {"$regex": f"^{player_name}$", "$options": "i"},
                "server_id": server_id
            }
            
            player = await players_collection.find_one(player_query)
            
            if not player:
                await ctx.respond(f"‚ùå Player '{player_name}' not found on server '{server['name']}'")
                return
                
            # Get player's ID
            player_id = str(player["_id"])
            
            # Get deaths collection
            deaths_collection = await self.db.get_collection("deaths")
            
            # Find nemesis - players who killed this player the most
            nemesis_pipeline = [
                {"$match": {"victim_id": player_id, "server_id": server_id}},
                {"$group": {
                    "_id": "$killer_id",
                    "count": {"$sum": 1},
                    "killer_name": {"$first": "$killer_name"},
                    "latest_kill": {"$max": "$timestamp"}
                }},
                {"$sort": {"count": -1}},
                {"$limit": 5}
            ]
            
            nemesis_results = await deaths_collection.aggregate(nemesis_pipeline).to_list(None)
            
            # Find prey - players this player killed the most
            prey_pipeline = [
                {"$match": {"killer_id": player_id, "server_id": server_id}},
                {"$group": {
                    "_id": "$victim_id",
                    "count": {"$sum": 1},
                    "victim_name": {"$first": "$victim_name"},
                    "latest_kill": {"$max": "$timestamp"}
                }},
                {"$sort": {"count": -1}},
                {"$limit": 5}
            ]
            
            prey_results = await deaths_collection.aggregate(prey_pipeline).to_list(None)
            
            # Create embed
            embed = discord.Embed(
                title=f"üîÑ Rivalries for {player_name}",
                description=f"Top rivals on server '{server['name']}'",
                color=discord.Color.purple()
            )
            
            # Add nemesis info
            if nemesis_results:
                nemesis_text = "\n".join([f"**{result['killer_name']}** - Killed you {result['count']} times" for result in nemesis_results])
                embed.add_field(
                    name="‚ò†Ô∏è Your Nemesis",
                    value=nemesis_text,
                    inline=False
                )
            else:
                embed.add_field(
                    name="‚ò†Ô∏è Your Nemesis",
                    value="No rivals found who have killed you",
                    inline=False
                )
            
            # Add prey info
            if prey_results:
                prey_text = "\n".join([f"**{result['victim_name']}** - You killed them {result['count']} times" for result in prey_results])
                embed.add_field(
                    name="üèπ Your Prey",
                    value=prey_text,
                    inline=False
                )
            else:
                embed.add_field(
                    name="üèπ Your Prey",
                    value="No players found that you've killed",
                    inline=False
                )
            
            # Add footer
            embed.set_footer(text=f"Server: {server['name']} ‚Ä¢ Premium feature")
            
            # Send embed
            await ctx.respond(embed=embed)
            
        except Exception as e:
            logger.error(f"Error in stats_rivals: {e}")
            await ctx.respond(f"‚ùå Error retrieving rivalry data: {e}")